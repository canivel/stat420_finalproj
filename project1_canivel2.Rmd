---
title: "project"
author: "Danilo Canivel(canivel2)"
date: "7/31/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r eval=FALSE}
library(lubridate)
library(cluster)
library(tidyverse)
library(caret)
library(magrittr)
library(Matrix)
```


## Read Data

```{r}
nrows = 1000000
data = read.csv("./input/train.csv", stringsAsFactors=FALSE, nrows=nrows)
```

## Feature Engineering

```{r}
features_eng = function(data, istrain=TRUE){
  
  if(istrain == TRUE){
    data = data[complete.cases(data),]
    # Remove Negative Fare and No Passenger
    data = data[(data$fare_amount > 0) & (data$passenger_count > 0),]
  }
  
  
  # Convert to datetime obj
  data$pickup_datetime = as_datetime(data$pickup_datetime, tz="UTC")

  
  
  # factorization
  data$year = as.factor(year(data$pickup_datetime))
  data$month = as.factor(month(data$pickup_datetime))
  data$day = as.factor(day(data$pickup_datetime))
  data$weekday = as.factor(weekdays(data$pickup_datetime))
  print(dim(data))
  #factor time of the day
  hour = hour(data$pickup_datetime)
  data$time = as.factor(ifelse(hour < 7, "Overnight", 
                               ifelse(hour < 11, "Morning", 
                                      ifelse(hour < 16, "Noon",
                                             ifelse(hour < 20, "Evening",
                                                    ifelse(hour < 23, "night", "overnight")
                        )))))
  print(dim(data))
  # compare locations
  data$dlat = data$dropoff_latitude - data$pickup_latitude
  data$dlon = data$dropoff_longitude - data$pickup_longitude 
  
  #Compute haversine distance
  earth_radius = 6371 #in kms
  data$hav = sin(data$dlat/2.0)**2 + cos(data$pickup_latitude) * cos(data$dropoff_latitude) * sin(data$dlon/2.0)**2
  data$haversine = round(x = 2 * earth_radius * asin(sqrt(data$hav)), digits = 4)
  print(dim(data))
  #Compute Bearing distance
  data$dlon = data$pickup_longitude - data$dropoff_longitude
  data$bearing = atan2(sin(data$dlon * cos(data$dropoff_latitude)), cos(data$pickup_latitude) * sin(data$dropoff_latitude) - sin(data$pickup_latitude) * cos(data$dropoff_latitude) * cos(data$dlon))
  print(dim(data))
  return (data)
  
}
```

```{r}
data = features_eng(data = data)
```

```{r}
### Outlier Pickup locations 
  data = data[data$pickup_longitude < median(data$pickup_longitude) + 1.5 * IQR( data$pickup_longitude) &
              data$pickup_longitude > median(data$pickup_longitude - 1.5 * IQR(data$pickup_longitude)) &
              data$pickup_latitude < median(data$pickup_latitude) + 1.5 * IQR(data$pickup_latitude) &
              data$pickup_latitude > median(data$pickup_latitude) - 1.5 * IQR(data$pickup_latitude),]
  print(dim(data))
  # Outlier Dropoff locations
  data = data[data$dropoff_longitude < median(data$dropoff_longitude) + 1.5 * IQR(data$dropoff_longitude) &
              data$dropoff_longitude > median(data$dropoff_longitude - 1.5 * IQR(data$dropoff_longitude)) &
              data$dropoff_latitude < median(data$dropoff_latitude) + 1.5 * IQR(data$dropoff_latitude) &
              data$dropoff_latitude > median(data$dropoff_latitude) - 1.5 * IQR(data$dropoff_latitude),]
  print(dim(data))
  # Outlier Fare Amount
  data = data[data$fare_amount < median(data$fare_amount) + 1.5 * IQR(data$fare_amount),]
```



```{r}
inds = sample.int(nrow(data), size=nrow(data) * 0.8) 
train = data[inds,]
test = data[-inds,]
dim(train)
dim(test)
head(train)
```

```{r}
calc_rmse = function(model) {
  sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}

calc_rmse2 = function(model, data){
  sqrt(sum((data$fare_amount - predict(model, newdata=data))^2) / nrow(data))
}
```


## Multiple Linear Regression

```{r}
m_additive = lm(fare_amount ~ dropoff_longitude + dropoff_latitude + passenger_count + year + month + day + weekday + time + dlat + dlon + haversine + bearing, train)
```

```{r}
calc_rmse(m_additive)
calc_rmse2(m_additive, test)
```

```{r}
n = length(resid(m_additive))
m_add_mod_back_bic = step(m_additive, direction = "backward", k = log(n))
```

```{r}
m_additive2 = lm(fare_amount ~ dropoff_longitude + year + weekday + time + dlat + 
    haversine + bearing, train)
```

```{r}
calc_rmse(m_additive2)
calc_rmse2(m_additive2, test)
```

```{r}
library('faraway')
round(vif(m_additive), 3)

```


```{r}
test_kaggle = read.csv("./input/test.csv", stringsAsFactors=FALSE)
test_kaggle = features_eng(data = test_kaggle, FALSE)
```

```{r}
#---------------------------
cat("Making submission file...\n")

read.csv("./input/sample_submission.csv") %>%  
  mutate(fare_amount = predict(m_additive2, test_kaggle)) %>%
  write_csv("sub_lm_aditive_4.csv")
```

```{r}
library(xgboost)
target = data$fare_amount

#train = train %>% select (- fare_amount)
#test = test %>% select (- fare_amount)

dvalid = xgb.DMatrix(data = data.matrix(test), label = data[-inds])
dtrain = xgb.DMatrix(data = data.matrix(train), label = data[inds])

p = list(objective = "reg:linear",
          eval_metric = "rmse",
          max_depth = 8 ,
          eta = .05, #.05
          subsample=1,
          colsample_bytree=0.8,
          num_boost_round=1000,
          nrounds = 6000)

set.seed(0)
m_xgb = xgb.train(p, dtrain, p$nrounds, list(val = dvalid), print_every_n = 10, early_stopping_rounds = 100)
```
##XGB Importance
```{r}
xgb.importance(colnames(dtrain), model = m_xgb)
```

